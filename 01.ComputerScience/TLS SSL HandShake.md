# TLS/SSL HandShake

## SSL

- 보안 소켓 계층(Secure Sockets Layer)
- 웹사이트와 브라우저 사이(또는 두 서버 사이) 전송되는 데이터를 암호화하여 인터넷 연결을 보호
- TCP/IP 네트워크 통신에 적용
- well-known 포트가 할당되어 있음
    - https : 443/tcp
    - smtps : 265/tcp
    - ftps : 990/tcp
    - telnets : 992/tcp
- 알려진 취약성이 여러가지 있음 → 보안 전문가들은 SSL의 사용을 중단하라고 권장

## TLS

- 전송 계층 보안(Transport Layer Security)
- SSL을 기반으로 설계
- 컴퓨터 네트워크에 통신 보안을 제공하기 위해 설게된 암호 규약
- TCP/IP 네트워크 통신에 적용
- 전송 계층(Transport Layer) 종단간 보안과 데이터 무결성 보장 → 암호화된 통신 지원

## SSL/TLS

- 역할
    - 네트워크 통신을 사용하는 모든 데이터를 암호화
    - 웹 서버 인증
- 현재 SSL이라고 해도 결국 TLS 최신 버전을 지원하고 있으나, SSL이 더 유명하기 때문에 아직 SSL이라는 단어를 쓰고 있음

## 미리 알아야 할 용어

- CA : 인증 기관. 디지털 인증서를 발급하는 하나의 단위이다.

## HandShake

- 채널에 대한 정상적인 통신이 시작되기 전, 두 채널의 통신 보안에 쓸 파라미터를 정하는 과정이다.
- 순서는 아래와 같다

![Untitled](TLS%20SSL%20HandShake%206bc8d8ae10534670bbcdf7c85737ab5e/Untitled.png)

### 1. Client Hello

클라이언트가 서버에 통신을 원한다는 client hello 메세지를 보낸다.

- 클라이언트 랜덤 : 클라이언트가 생성하는 32 바이트 난수값
- 클라이언트가 지원하는 SSL/TLS 프로토콜 버전
- 클라이언트가 지원하는 암호화 방식(여러 개)
- 압축 방식 및 기타 정보
- 세션 ID : 이미 생성된 세션을 재사용 하는 경우에 전송. 처음 진행하는 거라면 빈값을 보낸다.

등 통신에 필요한 정보를 전송한다.

### 2. Server Hello

서버는 클라이언트가 보낸 암호 알고리즘과 기타 필요한 정보를 받고 응답한다.

- CipherSuite : 클라이언트가 보낸 암호화 방식 중 서버도 지원하는 방식을 찾아 전달한다.
- Session ID : 서버와 클라인트가 공유할 세션 ID
- 서버 랜덤 : 서버가 생성한 32 바이트 난수값
- CA 공개 인증서 : 서드 파티(인증 기관)에서 발급 받은 인증서. 이 인증서 안에는 앞으로 통신 이후 사용할 대칭키가 생성되기 전, handshake 과정에서 사용할 서버의 공개키가 포함된다. 이 인증서는 CA의 비밀키로 암호화되어 발급된 상태이다.
- Server Key Exchange 메세지(옵션) : 키 교환에 필요한 정보를 전달
- 클라이언트의 CA 인증서 요청(옵션) : 요청하는 경우 서버 측에서 인증 가능한 인증기관 목록을 제공한다

### 3. 클라이언트가 CA 인증서 확인

클라이언트는 서버가 보낸 CA 공개 인증서를 확인한다. 클라이언트의 브라우저에는 ‘신뢰할 수 있는 인증 기관’ 목록이 존재하는데, 해당 인증서를 발급한 기관이 목록 안에 속하는지 확인한다.

→ OpenSSL로 자체 서명 인증서를 발급한 후 HTTPS 서비스를 제공할 때 ‘신뢰할 수 없는 인증서’라는 경고 문구가 뜨는 것이 이 때문이다. 자체 서명이라 발급 기관 목록에 없어서....


만일 목록에 속하지 않는 기관이 발급한 인증서라면 ‘보안 인증서에 문제가 있습니다’라는 문구가 뜨고 접근을 제한한다.


목록에 속하는 기관이 발급한 인증서라면, 해당 CA의 공개키를 사용해 인증서가 복호화되는지 확인한다. 복호화된다면 해당 CA에서 발급한 인증서가 맞다는 뜻이다.

복호화까지 정상적으로 진행된다면 서버는 해당 CA에 의해 인증되었다는 걸 알 수 있다.

### 4. Client key exchange

CA 인증서에 대한 신뢰성이 확보되었다면, 키 교환을 진행한다.

- premaster secret : 대칭키 교환에 필요한 정보. 예를 들어 RSA 방식에서는 난수값을 생성하여 서버 인증서의 공개키로 암호화 해서 전송한다.
- 클라이언트 CA 인증서 : 서버에서 요구한 경우 전송한다
- 클라이언트의 개인키로 암호화된 데이터 : 서버가 CA 인증서를 요구한 경우 전송한다. 지금까지 주고받은 handshake 메세지와 master secret을 조합한 해시값에 클라이언트 개인키로 서명하여 전달한다. CA 인증서에 대한 개인키를 클라이언트가 가지고 있음을 인증하기 위해 사용한다.

### 5. 서버가 CA 인증서 확인

서버는 클라이언트의 인증서를 확인한다. 신뢰할 수 있는 인증서라면, 클라이언트가 전송한 premaster secret을 활용하여 대칭키를 생성한다.

### 6. Client “finished”

클라이언트는 handshake 과정이 완료되었다는 finished 메시지를 전송한다.

### 7. Change Cipher Spec

서버가 클라이언트에게이제부터 같이 정한 암호로 통신함을 알린다.

### 8. Server “finished”

서버도 협상 완료를 클라이언트에게 전송한다.

### 9. Exchange Messages

이제 클라이언트와 서버는 정해진 master key (대칭키)로 데이터를 암호화하여 통신한다.

### 왜 대칭키를 만들어서 통신할까?

모든 통신을 공개키 방식으로 한다면 웹 서버와 브라우저에 많은 부담이 되기 때문에 대칭키를 정하는 데에 공개키를 활용하는 방식으로 사용한다.